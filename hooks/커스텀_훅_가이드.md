# 🪝 Supabase 통합 커스텀 훅 가이드

> **완전한 Supabase 통합을 위한 React 커스텀 훅**  
> API 요청, 로딩 상태 관리, 에러 처리를 자동화하여 개발 속도를 극대화합니다.

이 가이드는 Supabase와 완벽하게 통합된 커스텀 훅들의 사용법을 설명합니다. `config/supabase.js`의 API 클라이언트와 연동하여 인증, 데이터베이스 작업, 실시간 기능을 쉽게 구현할 수 있습니다.

---

## 🔄 useLoading 커스텀 훅

## 주요 기능 및 설명

useLoading 훅은 **Supabase API 호출을 포함한 모든 비동기 작업(Promise)**을 실행하며 로딩 상태를 자동으로 관리합니다. Supabase의 인증, 데이터베이스, 스토리지 작업과 완벽하게 연동되어 비동기 작업의 성공/실패와 관계없이 로딩 상태를 일관되게 처리하며, UI와 로직을 분리해 코드의 재사용성과 가독성을 높일 수 있습니다.

### 사용 시나리오

- **Supabase Auth**: `auth.signIn()`, `auth.signUp()` 등 인증 작업
- **Supabase Database**: `db.from('users').select()` 등 데이터베이스 쿼리
- **Supabase Storage**: `storage.upload()` 등 파일 업로드/다운로드
- **API 호출**: `apiClient.get()` 등의 비동기 요청 처리
- **복잡한 데이터 처리**: 데이터 필터링, 정렬, 연산 처리 등

### 장점

- 재사용성: 여러 컴포넌트에서 동일한 로딩 관리 로직을 공유 가능.

- 단순화: try/catch + 로딩 상태 업데이트를 한 줄로 간결하게 처리.

- UI 분리: 비동기 작업과 UI 렌더링을 명확히 분리해 구조적 설계 가능.

- 테스트 용이성: 독립적인 훅으로 단위 테스트 작성에 유리.

### 주의사항

- 에러 처리 필수: startLoading은 에러를 내부에서 처리하지 않고 그대로 던지므로, 호출부에서 try-catch로 처리해야 함.

- useCallback 최적화: startLoading은 useCallback으로 메모이제이션되어 있어 의존성 관리 주의.

### TIP

- LoadingSpinner 컴포넌트와 결합하면 빠르게 UX 개선 가능.

- 여러 API 요청을 병렬 또는 순차 처리할 때도 startLoading으로 감싸 사용 가능.

- 로딩 상태에 따라 버튼 비활성화, 스켈레톤 UI 등을 쉽게 구현 가능.

- 팀원들에게 useLoading 사용을 가이드하면 일관된 사용자 경험 제공 가능.

## 예시 코드

### 🔐 Supabase Auth와 함께 사용
```jsx
import React, { useState } from 'react';
import useLoading from '../hooks/useLoading';
import { auth } from '../config/supabase';
import LoadingSpinner from '../components/common/LoadingSpinner';

const LoginForm = () => {
  const [isLoading, startLoading] = useLoading();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [user, setUser] = useState(null);

  const handleSignIn = async () => {
    try {
      // Supabase Auth 로그인을 startLoading으로 감싸서 로딩 상태 자동 관리
      const data = await startLoading(auth.signIn(email, password));
      setUser(data.user);
      console.log('로그인 성공:', data.user.email);
    } catch (error) {
      console.error('로그인 실패:', error.message);
      alert(`로그인 실패: ${error.message}`);
    }
  };

  const handleSignUp = async () => {
    try {
      // 회원가입도 동일하게 로딩 상태 관리
      const data = await startLoading(auth.signUp(email, password, {
        data: { full_name: '새 사용자' }
      }));
      console.log('회원가입 성공:', data.user?.email);
      alert('회원가입 성공! 이메일 인증을 확인해주세요.');
    } catch (error) {
      console.error('회원가입 실패:', error.message);
      alert(`회원가입 실패: ${error.message}`);
    }
  };

  if (user) {
    return (
      <div>
        <h2>환영합니다, {user.email}!</h2>
        <button onClick={() => startLoading(auth.signOut()).then(() => setUser(null))}>
          {isLoading ? '로그아웃 중...' : '로그아웃'}
        </button>
      </div>
    );
  }

  return (
    <div>
      <h2>로그인</h2>
      <input
        type="email"
        placeholder="이메일"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        disabled={isLoading}
      />
      <input
        type="password"
        placeholder="비밀번호"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        disabled={isLoading}
      />
      <div>
        <button onClick={handleSignIn} disabled={isLoading}>
          {isLoading ? '로그인 중...' : '로그인'}
        </button>
        <button onClick={handleSignUp} disabled={isLoading}>
          {isLoading ? '가입 중...' : '회원가입'}
        </button>
      </div>
      {isLoading && <LoadingSpinner message="처리 중..." />}
    </div>
  );
};

export default LoginForm;
```

### 🗃️ Supabase Database와 함께 사용
```jsx
import React, { useState, useEffect } from 'react';
import useLoading from '../hooks/useLoading';
import { db } from '../config/supabase';

const UserProfile = ({ userId }) => {
  const [isLoading, startLoading] = useLoading();
  const [profile, setProfile] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [formData, setFormData] = useState({ username: '', full_name: '' });

  // 프로필 조회
  const fetchProfile = async () => {
    try {
      const data = await startLoading(
        db.from('profiles').select('*').eq('id', userId).single()
      );
      setProfile(data);
      setFormData({ username: data.username || '', full_name: data.full_name || '' });
    } catch (error) {
      console.error('프로필 조회 실패:', error.message);
    }
  };

  // 프로필 업데이트
  const updateProfile = async () => {
    try {
      const updatedData = await startLoading(
        db.from('profiles')
          .update(formData)
          .eq('id', userId)
          .select()
          .single()
      );
      setProfile(updatedData);
      setIsEditing(false);
      alert('프로필이 업데이트되었습니다!');
    } catch (error) {
      console.error('프로필 업데이트 실패:', error.message);
      alert(`업데이트 실패: ${error.message}`);
    }
  };

  useEffect(() => {
    if (userId) fetchProfile();
  }, [userId]);

  if (isLoading && !profile) {
    return <div>프로필을 불러오는 중...</div>;
  }

  return (
    <div>
      <h2>사용자 프로필</h2>
      {isEditing ? (
        <div>
          <input
            placeholder="사용자명"
            value={formData.username}
            onChange={(e) => setFormData({...formData, username: e.target.value})}
            disabled={isLoading}
          />
          <input
            placeholder="전체 이름"
            value={formData.full_name}
            onChange={(e) => setFormData({...formData, full_name: e.target.value})}
            disabled={isLoading}
          />
          <button onClick={updateProfile} disabled={isLoading}>
            {isLoading ? '저장 중...' : '저장'}
          </button>
          <button onClick={() => setIsEditing(false)} disabled={isLoading}>
            취소
          </button>
        </div>
      ) : (
        <div>
          <p>사용자명: {profile?.username || '미설정'}</p>
          <p>전체 이름: {profile?.full_name || '미설정'}</p>
          <button onClick={() => setIsEditing(true)} disabled={isLoading}>
            수정
          </button>
          <button onClick={fetchProfile} disabled={isLoading}>
            {isLoading ? '새로고침 중...' : '새로고침'}
          </button>
        </div>
      )}
    </div>
  );
};

export default UserProfile;
```

### 📦 Supabase Storage와 함께 사용
```jsx
import React, { useState } from 'react';
import useLoading from '../hooks/useLoading';
import { storage } from '../config/supabase';

const FileUploader = ({ userId }) => {
  const [isLoading, startLoading] = useLoading();
  const [uploadedUrl, setUploadedUrl] = useState('');

  const handleFileUpload = async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    try {
      const fileName = `${userId}/${Date.now()}-${file.name}`;
      
      // 파일 업로드
      const uploadData = await startLoading(
        storage.upload('avatars', fileName, file)
      );
      
      // 공개 URL 가져오기
      const publicUrl = storage.getPublicUrl('avatars', uploadData.path);
      setUploadedUrl(publicUrl);
      
      alert('파일 업로드 성공!');
    } catch (error) {
      console.error('파일 업로드 실패:', error.message);
      alert(`업로드 실패: ${error.message}`);
    }
  };

  return (
    <div>
      <h3>파일 업로드</h3>
      <input 
        type="file" 
        onChange={handleFileUpload}
        disabled={isLoading}
        accept="image/*"
      />
      {isLoading && <p>파일 업로드 중...</p>}
      {uploadedUrl && (
        <div>
          <p>업로드 완료!</p>
          <img src={uploadedUrl} alt="업로드된 이미지" style={{maxWidth: '200px'}} />
        </div>
      )}
    </div>
  );
};

export default FileUploader;
```

---

---

## 📡 useApi 커스텀 훅

## 주요 기능 및 설명

useApi는 **Supabase API 클라이언트**와 완벽하게 통합된 커스텀 훅으로, 자동 요청/응답 관리, 로딩 및 에러 상태 관리, 수동 재요청(refetch) 기능을 제공합니다. `config/api.js`의 API 클라이언트를 활용하여 Supabase 데이터베이스 쿼리를 자동으로 실행하고 상태를 관리합니다.

**자동 Supabase 쿼리 실행:**

- 컴포넌트가 마운트되면 Supabase 클라이언트를 통해 자동으로 데이터 조회
- 테이블명 또는 쿼리 옵션이 변경되면 자동으로 다시 요청
- RLS(Row Level Security) 정책 자동 적용

**상태 관리:**

- data: 성공 시 받은 응답 데이터.

- loading: 요청 중 true.

- error: 요청 실패 시 에러 객체 저장.

**재요청 기능:**

- refetch() 함수를 통해 수동으로 API 요청을 다시 실행할 수 있음.

- 메모리 누수 방지

- 컴포넌트 언마운트 후에도 setState가 발생하지 않도록 useRef로 마운트 상태 추적.

### 사용 시나리오

- **사용자 프로필**: 로그인 후 사용자 정보 자동 로드
- **데이터 목록**: 게시글, 상품 등의 리스트 페이지
- **실시간 갱신**: refetch로 데이터 새로고침
- **권한 기반 데이터**: RLS 정책에 따른 사용자별 데이터 조회

### 장점

- 자동화: 마운트 시 자동 요청, 상태 자동 관리로 개발 속도 향상.

- 재사용성: 여러 API 요청 컴포넌트에 동일한 훅 재사용 가능.

- 간결성: 로딩/에러/데이터 상태를 훅 내부에서 일괄 처리.

- 안정성: 컴포넌트가 언마운트되었을 때 setState 방지 처리 포함.

### 주의사항

- **조회 전용**: 현재는 SELECT 쿼리에 최적화됨. INSERT/UPDATE/DELETE는 별도 함수 사용 권장
- **의존성 관리**: 쿼리 옵션이 객체일 경우 참조가 변경되어 의도치 않은 재실행 발생 가능
- **RLS 고려**: Row Level Security 정책에 따라 데이터 접근이 제한될 수 있음
- **에러 처리**: Supabase 에러는 UI에서 조건문으로 처리 (한국어 메시지 자동 변환)

### TIP

- **실시간 연동**: Supabase Realtime과 결합하여 데이터 변경 시 자동 갱신
- **캐싱 전략**: 중복 요청 방지를 위한 간단한 캐싱 로직 내장
- **인증 연동**: 사용자 로그인 상태에 따른 자동 데이터 필터링
- **에러 복구**: 네트워크 오류 시 자동 재시도 (config/api.js의 재시도 로직 활용)

### 🚀 Supabase 실시간 연동 예시
```jsx
import React, { useEffect } from 'react';
import useApi from '../hooks/useApi';
import { realtime } from '../config/supabase';

const RealtimeUserList = () => {
  const { data: users, loading, error, refetch } = useApi('/users');

  useEffect(() => {
    // Supabase Realtime으로 실시간 데이터 구독
    const subscription = realtime.subscribe(
      'users',
      (payload) => {
        console.log('사용자 데이터 변경:', payload);
        refetch(); // 데이터 변경 시 자동 새로고침
      }
    );

    return () => {
      realtime.unsubscribe(subscription);
    };
  }, [refetch]);

  if (loading) return <div>사용자 목록 로딩 중...</div>;
  if (error) return <div>에러: {error}</div>;

  return (
    <div>
      <h2>실시간 사용자 목록</h2>
      <button onClick={refetch}>새로고침</button>
      <ul>
        {users?.map(user => (
          <li key={user.id}>
            {user.full_name} ({user.email})
          </li>
        ))}
      </ul>
    </div>
  );
};

export default RealtimeUserList;
```

---

## 🎯 **통합 사용 패턴**

### 완전한 Supabase CRUD 컴포넌트 예시
```jsx
import React, { useState } from 'react';
import useApi from '../hooks/useApi';
import useLoading from '../hooks/useLoading';
import { db, auth } from '../config/supabase';

const UserManager = () => {
  const { data: users, loading: listLoading, refetch } = useApi('/users');
  const [isLoading, startLoading] = useLoading();
  const [newUser, setNewUser] = useState({ name: '', email: '' });

  // 새 사용자 생성
  const createUser = async () => {
    try {
      await startLoading(
        db.from('profiles').insert({
          username: newUser.name,
          full_name: newUser.name,
          // auth.uid()로 현재 사용자 ID 자동 설정
        })
      );
      setNewUser({ name: '', email: '' });
      refetch(); // 목록 새로고침
      alert('사용자 생성 완료!');
    } catch (error) {
      alert(`생성 실패: ${error.message}`);
    }
  };

  // 사용자 삭제
  const deleteUser = async (userId) => {
    if (!confirm('정말 삭제하시겠습니까?')) return;
    
    try {
      await startLoading(
        db.from('profiles').delete().eq('id', userId)
      );
      refetch(); // 목록 새로고침
      alert('사용자 삭제 완료!');
    } catch (error) {
      alert(`삭제 실패: ${error.message}`);
    }
  };

  const loading = listLoading || isLoading;

  return (
    <div>
      <h2>사용자 관리</h2>
      
      {/* 새 사용자 생성 폼 */}
      <div style={{ marginBottom: '20px', padding: '20px', border: '1px solid #ddd' }}>
        <h3>새 사용자 추가</h3>
        <input
          placeholder="이름"
          value={newUser.name}
          onChange={(e) => setNewUser({...newUser, name: e.target.value})}
          disabled={loading}
        />
        <button onClick={createUser} disabled={loading || !newUser.name}>
          {isLoading ? '생성 중...' : '사용자 추가'}
        </button>
      </div>

      {/* 사용자 목록 */}
      <div>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <h3>사용자 목록</h3>
          <button onClick={refetch} disabled={loading}>
            {listLoading ? '로딩 중...' : '새로고침'}
          </button>
        </div>
        
        {listLoading && !users ? (
          <div>사용자 목록 로딩 중...</div>
        ) : users?.length === 0 ? (
          <div>등록된 사용자가 없습니다.</div>
        ) : (
          <ul style={{ listStyle: 'none', padding: 0 }}>
            {users?.map(user => (
              <li key={user.id} style={{ 
                padding: '10px', 
                margin: '5px 0', 
                border: '1px solid #eee',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center'
              }}>
                <div>
                  <strong>{user.full_name || user.username}</strong>
                  <br />
                  <small style={{ color: '#666' }}>
                    생성일: {new Date(user.created_at).toLocaleDateString()}
                  </small>
                </div>
                <button 
                  onClick={() => deleteUser(user.id)}
                  disabled={loading}
                  style={{ color: 'red' }}
                >
                  {isLoading ? '삭제 중...' : '삭제'}
                </button>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
};

export default UserManager;
```

---

## 💡 **성능 최적화 팁**

### 1. 적절한 훅 선택
- **useApi**: 자동 데이터 로딩이 필요한 경우 (목록, 상세 페이지)
- **useLoading**: 사용자 액션에 따른 수동 실행 (생성, 수정, 삭제)

### 2. 메모이제이션 활용
```jsx
const queryOptions = useMemo(() => ({
  select: 'id,name,email,created_at',
  order: 'created_at.desc',
  limit: 20
}), []);

const { data } = useApi('/users', queryOptions);
```

### 3. 조건부 실행
```jsx
// 로그인한 사용자만 데이터 로드
const { data } = useApi(user ? '/profile' : null);
```

이 가이드를 통해 Supabase와 완전히 통합된 React 애플리케이션을 효율적으로 구축할 수 있습니다! 🚀
