# 🧪 테스트 설정 가이드

> 현대적 테스트 전략과 기업 수준의 품질을 공모전에서 실현하는 가이드입니다.

이 문서는 **우아한형제들**과 **토스**의 테스트 철학을 바탕으로, 공모전/해커톤 기간 (10~14일)에 최적화된 실용적 테스트 전략을 제시합니다. 사용자 중심의 외부 인터페이스 테스트에 집중하여 높은 ROI와 장기적 생산성을 동시에 확보합니다.

## 📌 **모던 테스트 전략 개요**

### **🎯 테스트 철학 (우아한형제들 + 토스 인사이트)**
1. **사용자 행동 기반 테스트**: 내부 구현보다 외부 인터페이스 검증
2. **계층별 책임 분리**: 단위/컴포넌트/E2E 테스트의 명확한 경계
3. **전략적 테스트 선택**: 장기적 생산성과 안정성 향상 목표
4. **중복 제거 및 목적 집중**: 유지보수 용이성 확보

### **📊 테스트 계층별 목적과 범위**

| 계층 | 목적 | 범위/대상 | 예시 | 시간 할당 |
|------|------|-----------|------|-----------|
| **단위 테스트** | 핵심 로직 검증 | 함수, 유틸리티 | `getAvailablePoint()`, `validateForm()` | 30분 |
| **컴포넌트 테스트** | 사용자 인터페이스와 상호작용 | React 컴포넌트 | `<CouponSection />`, `<LoginForm />` | 기능당 15분 |
| **E2E 테스트** | 실제 사용자 흐름 전체 | 핵심 비즈니스 플로우 | 로그인 → 주문 → 결제 | 필요시에만 |

### **🚀 ROI 기반 우선순위**
1. 🔥 **최우선**: 비즈니스 로직 함수 → 계산/검증 오류 방지
2. ⚡ **높은 우선순위**: 핵심 컴포넌트 → 사용자 경험 보장
3. 🎯 **중간 우선순위**: 환경변수/유틸리티 → 안정성 확보
4. 🔄 **낮은 우선순위**: E2E 테스트 → 통합 검증

---

## 🛠️ **1. 환경 설정**

### **🔧 패키지 설치 (완전 초보자 가이드)**

**1단계: 기본 테스트 패키지 설치**
```bash
# 핵심 테스트 라이브러리 설치 (필수)
npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom

# 추가 유틸리티 (선택적)
npm install -D @vitest/ui msw
```

**2단계: 패키지별 역할 이해**
- **vitest**: 테스트 실행 엔진 (Jest의 Vite 버전, 더 빠름)
- **@testing-library/react**: 컴포넌트를 테스트용으로 렌더링
- **@testing-library/jest-dom**: DOM 검증 메서드 (`toBeInTheDocument()` 등)
- **@testing-library/user-event**: 실제 사용자처럼 클릭/타이핑 시뮬레이션
- **jsdom**: 브라우저 없이 DOM 환경 시뮬레이션
- **@vitest/ui**: 브라우저에서 테스트 결과 시각화 (디버깅용)
- **msw**: API 모킹 (서버 요청 시뮬레이션)

### **Vitest 설정 파일**
```js
// vitest.config.js
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    setupFiles: './src/setupTests.js',
    globals: true,
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@components': path.resolve(__dirname, './src/components'),
      '@utils': path.resolve(__dirname, './src/utils'),
    },
  },
})
```

### **테스트 환경 설정**
```js
// src/setupTests.js
import '@testing-library/jest-dom'

// 환경변수 모킹
Object.defineProperty(import.meta, 'env', {
  value: {
    MODE: 'test',
    VITE_API_BASE_URL: 'http://localhost:3000/api',
    VITE_API_TIMEOUT: '5000',
    VITE_DEBUG_MODE: 'true',
    VITE_ENABLE_ANALYTICS: 'false',
    VITE_APP_NAME: 'Test App',
    VITE_APP_VERSION: '1.0.0',
  },
  writable: true,
})

// Console 모킹 (불필요한 로그 제거)
global.console = {
  ...console,
  warn: jest.fn(),
  error: jest.fn(),
}
```

### **package.json 스크립트 추가**
```json
{
  "scripts": {
    "test": "vitest",
    "test:run": "vitest run",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage",
    "test:watch": "vitest --watch",
    "test:silent": "vitest run --silent"
  }
}
```

---

## 🧪 **2. 테스트 작성 가이드**

### **파일 구조**
```
src/
├── utils/
│   ├── env.js
│   └── __tests__/
│       └── env.test.js
├── components/
│   ├── Button.jsx
│   └── __tests__/
│       └── Button.test.jsx
└── setupTests.js
```

### **명명 규칙**
- **테스트 파일**: `*.test.js`, `*.test.jsx`
- **테스트 디렉토리**: `__tests__/`
- **Mock 파일**: `__mocks__/`

---

## 🔥 **3. 모던 테스트 패턴별 예시**

### **📍 테스트 작성 기본 원칙 (초보자 필독)**

**🎯 좋은 테스트의 특징:**
- **사용자 관점**: "버튼 클릭 시 메시지가 바뀐다" (구현 방식 X)
- **독립성**: 다른 테스트와 영향 없이 실행
- **명확성**: 테스트 이름만 봐도 무엇을 검증하는지 알 수 있음
- **신뢰성**: 같은 코드는 항상 같은 결과

**❌ 피해야 할 패턴:**
```js
// Bad: 내부 구현 테스트
expect(component.state.isLoading).toBe(false)

// Good: 사용자가 보는 결과 테스트  
expect(screen.getByText('완료')).toBeInTheDocument()
```

---

### **🧩 1. 단위 테스트: 비즈니스 로직 검증**

**예시: 쿠폰 할인 계산 로직 (우아한형제들 스타일)**
```js
// src/lib/__tests__/couponUtils.test.js
import { describe, it, expect } from 'vitest'
import { getAvailablePoint, calculateDiscount } from '../couponUtils.js'

describe('쿠폰 할인 계산 로직', () => {
  describe('getAvailablePoint() - 사용 가능 포인트 계산', () => {
    // ✅ 핵심 비즈니스 로직: 주문금액 - 쿠폰할인 vs 보유포인트 중 작은 값
    it('포인트가 충분할 때: 주문금액 - 쿠폰할인액을 반환', () => {
      const orderAmount = 8000
      const couponDiscount = 5000  
      const userPoint = 10000
      
      expect(getAvailablePoint(orderAmount, couponDiscount, userPoint)).toBe(3000)
    })

    it('포인트가 부족할 때: 보유 포인트 전액을 반환', () => {
      const orderAmount = 8000
      const couponDiscount = 5000
      const userPoint = 2000
      
      expect(getAvailablePoint(orderAmount, couponDiscount, userPoint)).toBe(2000)
    })

    it('쿠폰 할인이 주문금액보다 클 때: 0을 반환', () => {
      const orderAmount = 3000
      const couponDiscount = 5000
      const userPoint = 10000
      
      expect(getAvailablePoint(orderAmount, couponDiscount, userPoint)).toBe(0)
    })
  })

  describe('calculateDiscount() - 총 할인 계산', () => {
    it('쿠폰 + 포인트 할인 합계를 정확히 계산', () => {
      expect(calculateDiscount(5000, 2000)).toBe(7000)
    })
  })
})
```

**💡 단위 테스트 작성 팁:**
- **한 함수당 3-5개 테스트**: 정상 케이스 + 경계 케이스 + 예외 케이스
- **의미있는 테스트명**: "~할 때: ~을 반환한다"
- **순수 함수 우선**: 입력 → 출력이 명확한 함수부터

### **🎨 2. 컴포넌트 테스트: 사용자 인터페이스 검증**

**예시: 쿠폰 선택 컴포넌트 (사용자 행동 기반)**
```jsx
// src/components/__tests__/CouponSection.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import CouponSection from '../CouponSection.jsx'

describe('<CouponSection /> - 쿠폰 선택 기능', () => {
  // ✅ 사용자 시나리오: "쿠폰을 선택하면 할인된 금액이 보인다"
  it('쿠폰 선택 시 할인 후 금액이 정확히 표시된다', async () => {
    const user = userEvent.setup()
    
    // Given: 8000원 주문, 5000원 쿠폰이 있는 상황
    render(<CouponSection orderAmount={8000} />)
    
    // When: 사용자가 5천원 할인쿠폰을 클릭
    const couponButton = await screen.findByText('5천원 할인쿠폰')
    await user.click(couponButton)
    
    // Then: 할인 후 금액 3000원이 표시됨
    expect(screen.getByText('할인 후 금액: 3,000원')).toBeInTheDocument()
  })

  it('쿠폰 선택 시 해당 쿠폰이 활성화 상태로 표시된다', async () => {
    const user = userEvent.setup()
    render(<CouponSection orderAmount={8000} />)
    
    const couponButton = await screen.findByText('5천원 할인쿠폰')
    await user.click(couponButton)
    
    // 선택된 쿠폰에 'selected' 클래스 또는 스타일 적용 확인
    expect(couponButton).toHaveClass('selected')
  })

  it('쿠폰이 없을 때 "사용 가능한 쿠폰이 없습니다" 메시지를 표시한다', () => {
    render(<CouponSection orderAmount={8000} coupons={[]} />)
    
    expect(screen.getByText('사용 가능한 쿠폰이 없습니다')).toBeInTheDocument()
  })
})
```

**예시: 로그인 폼 컴포넌트**
```jsx
// src/components/__tests__/LoginForm.test.jsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import LoginForm from '../LoginForm.jsx'

// API 모킹 (MSW 대신 간단한 vi.mock 사용)
const mockLogin = vi.fn()
vi.mock('../api/auth', () => ({
  login: mockLogin
}))

describe('<LoginForm /> - 로그인 기능', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('올바른 이메일/비밀번호 입력 시 로그인이 성공한다', async () => {
    const user = userEvent.setup()
    mockLogin.mockResolvedValue({ success: true })
    
    render(<LoginForm />)
    
    // 사용자가 폼에 입력
    await user.type(screen.getByLabelText('이메일'), 'test@example.com')
    await user.type(screen.getByLabelText('비밀번호'), 'password123')
    await user.click(screen.getByRole('button', { name: '로그인' }))
    
    // 결과 검증
    expect(mockLogin).toHaveBeenCalledWith('test@example.com', 'password123')
    expect(await screen.findByText('로그인 성공')).toBeInTheDocument()
  })

  it('필수 입력값이 비어있으면 에러 메시지를 표시한다', async () => {
    const user = userEvent.setup()
    render(<LoginForm />)
    
    // 빈 상태로 로그인 버튼 클릭
    await user.click(screen.getByRole('button', { name: '로그인' }))
    
    expect(screen.getByText('이메일을 입력해주세요')).toBeInTheDocument()
    expect(screen.getByText('비밀번호를 입력해주세요')).toBeInTheDocument()
  })
})
```

**💡 컴포넌트 테스트 작성 가이드 (초보자용):**

**1. 기본 구조 이해**
```jsx
// 1. 필요한 것들 import
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'

// 2. 컴포넌트 렌더링
render(<MyComponent />)

// 3. 요소 찾기 (사용자가 보는 방식으로)
screen.getByText('버튼 텍스트')        // 텍스트로 찾기
screen.getByRole('button')            // 역할로 찾기 (권장)
screen.getByLabelText('이메일')       // label로 찾기

// 4. 사용자 액션 시뮬레이션
const user = userEvent.setup()
await user.click(button)             // 클릭
await user.type(input, '텍스트')      // 타이핑

// 5. 결과 검증
expect(element).toBeInTheDocument()   // 화면에 있는지
expect(element).toHaveClass('active') // CSS 클래스 확인
```

**2. 쿼리 메서드 우선순위 (접근성 기반)**
```jsx
// ✅ 1순위: getByRole (가장 사용자 친화적)
screen.getByRole('button', { name: '제출' })
screen.getByRole('textbox', { name: '이메일' })

// ✅ 2순위: getByLabelText (폼 요소)
screen.getByLabelText('비밀번호')

// ✅ 3순위: getByText (버튼, 링크 텍스트)
screen.getByText('로그인')

// ❌ 피하기: getByTestId (최후의 수단)
screen.getByTestId('submit-button')
```

### **🌐 3. API 함수 테스트: 외부 의존성 모킹**

**예시: MSW를 활용한 현대적 API 테스트**
```js
// src/api/__tests__/userApi.test.js
import { describe, it, expect, beforeEach, afterEach } from 'vitest'
import { setupServer } from 'msw/node'
import { http, HttpResponse } from 'msw'
import { fetchUsers, createUser } from '../userApi.js'

// 🔧 Mock Service Worker로 실제 HTTP 요청 시뮬레이션
const server = setupServer(
  // GET /api/users 모킹
  http.get('/api/users', () => {
    return HttpResponse.json([
      { id: 1, name: 'John', email: 'john@example.com' },
      { id: 2, name: 'Jane', email: 'jane@example.com' }
    ])
  }),
  
  // POST /api/users 모킹
  http.post('/api/users', async ({ request }) => {
    const newUser = await request.json()
    return HttpResponse.json({ id: 3, ...newUser }, { status: 201 })
  })
)

describe('User API 함수', () => {
  beforeEach(() => server.listen())
  afterEach(() => server.resetHandlers())

  describe('fetchUsers() - 사용자 목록 조회', () => {
    it('서버에서 사용자 목록을 성공적으로 가져온다', async () => {
      const users = await fetchUsers()
      
      expect(users).toHaveLength(2)
      expect(users[0]).toEqual({
        id: 1,
        name: 'John',
        email: 'john@example.com'
      })
    })

    it('네트워크 오류 시 적절한 에러를 던진다', async () => {
      // 특정 테스트에서만 에러 응답 설정
      server.use(
        http.get('/api/users', () => {
          return new HttpResponse(null, { status: 500 })
        })
      )

      await expect(fetchUsers()).rejects.toThrow('Failed to fetch users')
    })
  })

  describe('createUser() - 새 사용자 생성', () => {
    it('새 사용자를 성공적으로 생성한다', async () => {
      const newUserData = { name: 'Bob', email: 'bob@example.com' }
      const createdUser = await createUser(newUserData)
      
      expect(createdUser).toEqual({
        id: 3,
        name: 'Bob',
        email: 'bob@example.com'
      })
    })
  })
})
```

**간단한 vi.mock 방식 (MSW 설정이 복잡할 때)**
```js
// src/api/__tests__/simpleUserApi.test.js
import { describe, it, expect, vi, beforeEach } from 'vitest'
import axios from 'axios'
import { fetchUsers } from '../userApi.js'

// axios 전체 모킹
vi.mock('axios')
const mockedAxios = vi.mocked(axios)

describe('간단한 User API 테스트', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('사용자 목록을 가져와서 올바른 형태로 반환한다', async () => {
    // Mock 응답 설정
    const mockUsers = [{ id: 1, name: 'John' }]
    mockedAxios.get.mockResolvedValue({ data: mockUsers })

    const result = await fetchUsers()

    expect(mockedAxios.get).toHaveBeenCalledWith('/api/users')
    expect(result).toEqual(mockUsers)
  })

  it('API 에러 시 적절히 처리한다', async () => {
    mockedAxios.get.mockRejectedValue(new Error('Network Error'))

    await expect(fetchUsers()).rejects.toThrow('Network Error')
  })
})
```

**💡 API 테스트 초보자 가이드:**

**1. 모킹 방식 선택 기준**
- **MSW 사용**: 실제 HTTP 요청에 가까운 테스트, 여러 API 함수 테스트
- **vi.mock 사용**: 간단한 함수 단위 테스트, 빠른 설정

**2. MSW 설정 방법 (완전 초보자용)**
```js
// 1. MSW 설치
npm install -D msw

// 2. 서버 설정 (setupTests.js 또는 각 테스트 파일)
import { setupServer } from 'msw/node'
import { http, HttpResponse } from 'msw'

const server = setupServer(
  // API 엔드포인트별로 모킹 설정
  http.get('/api/users', () => {
    return HttpResponse.json([{ id: 1, name: 'Test User' }])
  })
)

// 3. 테스트 lifecycle에 연결
beforeEach(() => server.listen())  // 테스트 시작 전
afterEach(() => server.resetHandlers())  // 각 테스트 후 초기화
```

**3. 테스트해야 할 것들**
- ✅ **성공 케이스**: 정상 응답 시 올바른 데이터 반환
- ✅ **에러 케이스**: 네트워크 오류, 4xx/5xx 응답 처리
- ✅ **호출 검증**: 올바른 URL, 헤더, 파라미터로 요청했는지
- ❌ **피할 것**: HTTP 상태 코드 자체 테스트 (서버 책임)

### **🚀 4. E2E 테스트: 핵심 사용자 흐름 검증**

**예시: Playwright를 활용한 실제 브라우저 테스트**
```js
// e2e/critical-user-flows.spec.js
import { test, expect } from '@playwright/test'

test.describe('핵심 사용자 플로우', () => {
  test('로그인 → 주문 → 결제 전체 흐름이 정상 작동한다', async ({ page }) => {
    // 1. 로그인 페이지 접속
    await page.goto('/login')
    
    // 2. 로그인 수행
    await page.fill('input[name="email"]', 'test@example.com')
    await page.fill('input[name="password"]', 'password123')
    await page.click('button[type="submit"]')
    
    // 3. 메인 페이지로 이동 확인
    await expect(page).toHaveURL('/dashboard')
    await expect(page.locator('h1')).toContainText('환영합니다')
    
    // 4. 상품 선택 및 주문
    await page.click('[data-testid="product-1"]')
    await page.click('button:has-text("장바구니 담기")')
    await page.click('button:has-text("주문하기")')
    
    // 5. 쿠폰 적용
    await page.click('button:has-text("쿠폰 선택")')
    await page.click('text=5천원 할인쿠폰')
    await expect(page.locator('.discount-amount')).toContainText('5,000원')
    
    // 6. 최종 주문 확인
    await page.click('button:has-text("결제하기")')
    await expect(page.locator('.success-message')).toContainText('주문이 완료되었습니다')
  })

  test('비로그인 상태에서 보호된 페이지 접근 시 로그인 페이지로 리다이렉트', async ({ page }) => {
    await page.goto('/dashboard')
    
    // 로그인 페이지로 자동 리다이렉트 확인
    await expect(page).toHaveURL('/login')
    await expect(page.locator('.login-message')).toContainText('로그인이 필요합니다')
  })
})
```

**초보자를 위한 E2E 테스트 설정 가이드:**

**1. Playwright 설치 및 설정**
```bash
# Playwright 설치
npm install -D @playwright/test

# 브라우저 설치 (Chrome, Firefox, Safari)
npx playwright install
```

**2. Playwright 설정 파일**
```js
// playwright.config.js
import { defineConfig } from '@playwright/test'

export default defineConfig({
  testDir: './e2e',
  timeout: 30000,
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure'
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] }
    }
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI
  }
})
```

**3. E2E 테스트 작성 패턴**
```js
// 좋은 E2E 테스트 구조
test('사용자 시나리오 설명', async ({ page }) => {
  // Given: 초기 상태 설정
  await page.goto('/start-page')
  
  // When: 사용자 액션 시퀀스
  await page.click('button')
  await page.fill('input', 'value')
  
  // Then: 최종 결과 검증
  await expect(page.locator('.result')).toContainText('예상 결과')
})
```

**💡 E2E 테스트 가이드라인:**

**✅ E2E로 테스트할 것:**
- 핵심 비즈니스 플로우 (로그인 → 주문 → 결제)
- 페이지 간 네비게이션
- 권한 및 인증 플로우
- 크로스 브라우저 호환성

**❌ E2E로 테스트하지 말 것:**
- 단순한 UI 컴포넌트 동작
- 단위 함수 로직
- API 응답 세부사항
- 세세한 밸리데이션 룰

**4. 공모전 환경에서의 E2E 전략:**
- **1개 핵심 플로우만**: 가장 중요한 사용자 여정 1개
- **빠른 실행**: 전체 실행 시간 5분 이내
- **실패 시 스크린샷**: 디버깅을 위한 시각적 증거
- **CI에서는 스킵**: 개발 완료 후 수동 실행

---

## 🚀 **5. 개발 워크플로우 통합**

### **📋 일일 테스트 워크플로우 (공모전 최적화)**

**🌅 개발 시작 시 (5분)**
```bash
# 1. 어제 작성한 테스트 확인
npm run test:run

# 2. 개발 모드로 실시간 테스트 시작
npm run test:watch
```

**⚡ 기능 개발 중 (지속적)**
```bash
# 새 기능 구현 후 즉시 테스트 작성
# 예: LoginForm 구현 → LoginForm.test.jsx 작성 (10분)

# 실시간으로 테스트 결과 확인 (watch 모드 활용)
# 빨간불 → 초록불 전환 확인
```

**🔍 PR 전 품질 검사 (10분)**
```bash
# 1. 전체 테스트 실행
npm run test:run

# 2. 커버리지 확인 (선택적)
npm run test:coverage

# 3. 코드 품질 검사와 함께
npm run lint && npm run format:check && npm run test:run
```

### **🛠️ 테스트 명령어 완전 가이드**

**기본 명령어**
```bash
# 모든 테스트 1회 실행
npm run test:run

# 파일 변경 시 자동 재실행 (개발 중 권장)
npm run test:watch

# 특정 테스트 파일만 실행
npm run test login.test.js

# 특정 패턴의 테스트만 실행
npm run test:run --grep "쿠폰"
```

**고급 명령어**
```bash
# 브라우저에서 테스트 결과 시각화
npm run test:ui

# 코드 커버리지 포함 실행
npm run test:coverage

# 조용한 모드 (CI용)
npm run test:run --silent

# 병렬 실행 비활성화 (디버깅용)
npm run test:run --no-parallel
```

### **🎯 VSCode 테스트 통합 설정**

**1. VSCode 확장 프로그램**
```json
// .vscode/extensions.json에 추가
{
  "recommendations": [
    "vitest.explorer",
    "ms-vscode.vscode-jest"
  ]
}
```

**2. VSCode 설정**
```json
// .vscode/settings.json에 추가  
{
  "vitest.enable": true,
  "testing.automaticallyOpenPeekView": "never",
  "testing.followRunningTest": false,
  "vitest.commandLine": "npm run test:run",
  "editor.rulers": [80],
  "editor.renderWhitespace": "boundary"
}
```

**3. 키보드 단축키 (선택적)**
```json
// .vscode/keybindings.json 생성
[
  {
    "key": "ctrl+shift+t",
    "command": "vitest.runAll"
  },
  {
    "key": "ctrl+t",
    "command": "vitest.runCurrent"
  }
]
```

### **🔄 Git Hook 통합 (미래 계획)**

**pre-commit 훅으로 테스트 자동화 (선택적)**
- Husky + lint-staged로 커밋 전 자동 테스트 실행
- 공모전 기간에는 우선순위 낮음, 수동 실행으로도 충분

### **📊 테스트 성능 모니터링**

**실행 시간 추적**
```bash
# 느린 테스트 식별
npm run test:run --reporter=verbose

# 테스트별 실행 시간 표시
npm run test:run --reporter=junit --outputFile=test-results.xml
```

**커버리지 임계값 설정**
```js
// vitest.config.js에 추가
{
  test: {
    coverage: {
      statements: 80,
      branches: 70,
      functions: 80,
      lines: 80
    }
  }
}
```

---

## 📊 **6. 공모전 최적화 테스트 전략**

### **🎯 우아한형제들 + 토스 방식의 현실적 적용**

**✅ DO: 기업에서 검증된 패턴**
- **사용자 관점 테스트**: "버튼 클릭 → 할인가 표시" (구현 방식 X)
- **외부 인터페이스 중심**: 함수 입력/출력, 컴포넌트 props/렌더링 결과
- **계층별 책임 분리**: 단위(로직) / 컴포넌트(UI) / E2E(플로우) 명확히 구분
- **전략적 선택**: ROI 높은 핵심 기능부터 (할인 계산 > 색상 변경)
- **빠른 피드백**: 실행 시간 전체 30초 이내

**❌ DON'T: 공모전에서 피해야 할 함정**
- **완벽한 커버리지 추구**: 80% 대신 핵심 기능 100% 커버리지
- **과도한 모킹**: 실제 동작 확인이 우선 (MSW > vi.mock)
- **구현 세부사항 테스트**: state 변화보다 사용자가 보는 결과
- **스냅샷 테스트**: 변경 빈도 높은 공모전에서는 유지보수 부담
- **복잡한 테스트 셋업**: 간단하고 이해하기 쉬운 테스트

### **⏰ 시간 관리 전략 (기업 실무 기반)**

**1일차: 테스트 환경 구축 (30분)**
```bash
# 빠른 환경 설정
npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom
```

**개발 기간: 기능별 테스트 작성**
- **비즈니스 로직**: 함수당 10분 (3-4개 케이스)
- **핵심 컴포넌트**: 컴포넌트당 15분 (렌더링 + 상호작용)
- **API 함수**: 함수당 5분 (성공/실패 케이스)

**마지막 주: 통합 검증**
- **E2E 테스트**: 1개 핵심 플로우만 (30분)
- **전체 테스트 실행**: 매일 1회 (5분)

### **📈 테스트 ROI 극대화 (토스 방식)**

**High Impact, Low Effort (우선순위 1)**
```js
// 할인 계산 로직 - 비즈니스 크리티컬
describe('할인 계산', () => {
  it('쿠폰 할인이 올바르게 적용된다', () => {
    expect(calculateDiscount(10000, 3000)).toBe(7000)
  })
})
```

**High Impact, High Effort (우선순위 2)**
```jsx
// 결제 플로우 - 사용자 경험 크리티컬
describe('결제 프로세스', () => {
  it('쿠폰 선택 후 최종 금액이 정확히 표시된다', async () => {
    // 복잡하지만 중요한 테스트
  })
})
```

**Low Impact, Low Effort (우선순위 3)**
```js
// 유틸리티 함수 - 안정성 확보
describe('formatPrice', () => {
  it('숫자를 통화 형식으로 변환한다', () => {
    expect(formatPrice(1000)).toBe('1,000원')
  })
})
```

**Low Impact, High Effort (스킵)**
- 색상 변경, 애니메이션 효과 등
- 복잡한 사용자 인터랙션 (드래그 앤 드랍 등)
- 세세한 밸리데이션 메시지

### **🔄 지속적인 품질 관리**

**매일 아침 루틴 (5분)**
```bash
# 1. 모든 테스트 실행
npm run test:run

# 2. 실패한 테스트 즉시 수정
# 3. 새 기능 개발 전 테스트 상태 확인
```

**PR 전 체크리스트**
- [ ] 새 기능에 대한 테스트 작성 완료
- [ ] 모든 테스트 통과 (`npm run test:run`)
- [ ] 핵심 로직 커버리지 100%
- [ ] 테스트 실행 시간 30초 이내

### **🎯 성공 지표**
- **테스트 실행 시간**: 전체 30초 이내
- **핵심 기능 커버리지**: 100% (비핵심 기능은 무시)
- **테스트 통과율**: 항상 100% (실패 시 즉시 수정)
- **버그 발견율**: 테스트로 90% 이상의 버그 사전 발견

---

## 🏆 **7. 실무 적용 가이드**

### **🚀 테스트 주도 개발 (TDD) 공모전 버전**

**Red → Green → Refactor 사이클 (간소화)**
```js
// 1. Red: 실패하는 테스트 작성 (2분)
describe('할인 계산 함수', () => {
  it('10000원 주문에 3000원 쿠폰 적용 시 7000원 반환', () => {
    expect(calculateDiscount(10000, 3000)).toBe(7000) // 아직 함수 없음
  })
})

// 2. Green: 테스트를 통과시키는 최소 코드 (3분)
function calculateDiscount(orderAmount, couponAmount) {
  return orderAmount - couponAmount
}

// 3. Refactor: 코드 개선 (5분)
function calculateDiscount(orderAmount, couponAmount) {
  if (orderAmount < 0 || couponAmount < 0) return 0
  return Math.max(0, orderAmount - couponAmount)
}
```

### **🎯 공모전 특화 전략**

**Week 1-2: 기반 다지기**
```bash
# Day 1: 환경 설정 (30분)
npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom

# Day 2-14: 기능 개발과 동시에 테스트 작성
# 새 기능 → 테스트 → 구현 → 검증 사이클
```

**Week 3: 통합 및 검증**
- 핵심 E2E 플로우 1개 작성
- 전체 테스트 실행 시간 최적화
- 성능 이슈 해결

**Week 4: 최종 점검**
- 데모 준비를 위한 안정성 확보
- 엣지 케이스 처리
- 최종 리팩토링

### **🔧 디버깅 및 문제 해결**

**일반적인 테스트 오류 해결법**

**1. 비동기 처리 오류**
```jsx
// ❌ 잘못된 방법
it('API 호출 테스트', () => {
  fetchData() // Promise 미처리
  expect(result).toBe('success')
})

// ✅ 올바른 방법
it('API 호출 테스트', async () => {
  const result = await fetchData()
  expect(result).toBe('success')
})
```

**2. DOM 요소 찾기 실패**
```jsx
// ❌ 잘못된 방법
expect(screen.getByText('버튼')).toBeInTheDocument() // 요소가 아직 렌더링되지 않음

// ✅ 올바른 방법
expect(await screen.findByText('버튼')).toBeInTheDocument() // 비동기 대기
```

**3. Mock 함수 초기화 누락**
```js
// ❌ 테스트 간 상태 공유
describe('API 테스트', () => {
  const mockFn = vi.fn()
  
  it('첫 번째 테스트', () => {
    mockFn('test1')
    expect(mockFn).toHaveBeenCalledTimes(1)
  })
  
  it('두 번째 테스트', () => {
    mockFn('test2')
    expect(mockFn).toHaveBeenCalledTimes(1) // 실패! 실제로는 2번 호출됨
  })
})

// ✅ 각 테스트마다 초기화
describe('API 테스트', () => {
  const mockFn = vi.fn()
  
  beforeEach(() => {
    vi.clearAllMocks() // 중요!
  })
  
  // 테스트들...
})
```

### **📚 학습 리소스 및 레퍼런스**

**핵심 문서**
- [Testing Library 공식 문서](https://testing-library.com/docs/react-testing-library/intro/)
- [Vitest 공식 가이드](https://vitest.dev/guide/)
- [우아한형제들 테스트 블로그](https://techblog.woowahan.com/17404/)

**실무 패턴 참고**
- [토스 프론트엔드 테스트](https://toss.tech/article/firesidechat_frontend_3)
- [React Testing Patterns](https://developer-bandi.github.io/post/frontend-testing/)

### **🎉 성공 사례 체크포인트**

**중간 점검 (Week 2)**
- [ ] 핵심 비즈니스 로직 100% 테스트 커버리지
- [ ] 주요 컴포넌트 렌더링 테스트 완료
- [ ] 전체 테스트 실행 시간 30초 이내
- [ ] 매일 테스트 실행하는 습관 정착

**최종 점검 (Week 4)**
- [ ] 1개 이상의 E2E 테스트 작성
- [ ] 모든 테스트 100% 통과
- [ ] 데모 시연 중 버그 0개 발생
- [ ] 팀원 모두 테스트 코드 이해 및 수정 가능

---

## 🚨 **자주 발생하는 문제**

### **1. 환경변수 모킹 오류**
**문제**: `import.meta.env` 접근 실패
**해결**: `setupTests.js`에서 올바른 모킹 설정

### **2. 경로 별칭 오류**
**문제**: `@utils/env` import 실패
**해결**: `vitest.config.js`에서 alias 설정 확인

### **3. 비동기 테스트 실패**
**문제**: Promise 처리 미완료
**해결**: `async/await` 또는 `waitFor` 사용

### **4. Mock 초기화 누락**
**문제**: 테스트 간 Mock 상태 공유
**해결**: `beforeEach`에서 `vi.clearAllMocks()`

---

## 📋 **최종 체크리스트**

### **🔧 초기 환경 설정 (Day 1)**
- [ ] `npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom` 실행
- [ ] `vitest.config.js` 파일 생성 및 설정
- [ ] `src/setupTests.js` 파일 생성
- [ ] `package.json`에 테스트 스크립트 추가
- [ ] `npm run test:run` 명령어 실행 확인

### **💻 개발 환경 통합 (Day 2)**
- [ ] VSCode Vitest 확장 프로그램 설치
- [ ] `.vscode/settings.json`에 테스트 설정 추가
- [ ] `npm run test:watch` 개발 모드 실행 확인
- [ ] 실시간 테스트 피드백 작동 확인

### **🧪 핵심 테스트 작성 (Week 1-3)**
- [ ] **비즈니스 로직 테스트**: 할인 계산, 가격 포맷팅 등 핵심 함수
- [ ] **컴포넌트 테스트**: 로그인 폼, 상품 목록 등 주요 UI
- [ ] **API 함수 테스트**: 사용자 조회, 주문 생성 등 서버 통신
- [ ] **유틸리티 테스트**: 환경변수, 공통 함수 등 기반 기능

### **🚀 품질 관리 프로세스 (Daily)**
- [ ] 매일 아침 `npm run test:run` 실행 (5분)
- [ ] 새 기능 개발 시 테스트 동시 작성
- [ ] PR 전 전체 테스트 통과 확인
- [ ] 테스트 실행 시간 30초 이내 유지

### **🎯 최종 검증 (Week 4)**
- [ ] **안정성**: 모든 테스트 100% 통과
- [ ] **성능**: 전체 테스트 실행 시간 30초 이내
- [ ] **커버리지**: 핵심 기능 100% 커버
- [ ] **E2E**: 1개 이상의 핵심 사용자 플로우 테스트
- [ ] **팀 공유**: 모든 팀원이 테스트 실행 및 수정 가능

### **📊 성공 지표 달성 확인**
- [ ] **버그 발견율**: 테스트로 90% 이상 버그 사전 차단
- [ ] **개발 속도**: 테스트 덕분에 리팩토링 부담 감소
- [ ] **코드 품질**: 명확한 사용자 시나리오 기반 테스트
- [ ] **유지보수성**: 3개월 후에도 쉽게 이해 가능한 테스트 코드

---

## 💡 **실무 꿀팁 & 마무리**

### **⚡ 성능 최적화 (기업 실무 노하우)**
- **병렬 실행**: Vitest의 기본 병렬 처리로 테스트 속도 2-3배 향상
- **선택적 실행**: `--grep` 플래그로 특정 테스트만 실행
- **메모리 최적화**: 큰 객체 생성은 `beforeEach`에서, 정리는 `afterEach`에서
- **Mock 재사용**: 동일한 API 모킹은 별도 헬퍼 파일로 분리

### **🔧 유지보수성 (장기적 관점)**
- **테스트도 코드**: 중복 제거, 명확한 네이밍, 적절한 추상화 적용
- **문서화**: 복잡한 테스트는 주석으로 의도 명시
- **일관성**: 팀 내 테스트 작성 규칙과 패턴 통일
- **점진적 개선**: 완벽함보다는 지속적인 품질 향상

### **👥 팀 협업 (공모전 필수)**
- **코드 리뷰**: 테스트 코드도 반드시 리뷰 대상에 포함
- **지식 공유**: 테스트 작성법을 팀원들과 정기적으로 공유
- **실패 대응**: 테스트 실패 시 우선순위 최상으로 즉시 수정
- **문서 유지**: 이 가이드를 프로젝트 상황에 맞게 지속 업데이트

### **🎯 최종 메시지**

이 가이드는 **우아한형제들**과 **토스**의 실무 경험을 바탕으로, 공모전이라는 제한적 환경에서도 **기업 수준의 테스트 품질**을 실현할 수 있도록 설계되었습니다.

**핵심은 완벽함이 아닌 실용성입니다.** 

- ✅ **사용자 관점의 테스트**로 실제 가치 검증
- ✅ **전략적 선택**으로 ROI 높은 테스트 우선
- ✅ **빠른 피드백**으로 개발 속도 가속화
- ✅ **지속적 품질 관리**로 안정성 확보

**10-14일의 짧은 기간이지만, 이 테스트 전략을 통해 장기적으로 확장 가능하고 유지보수 가능한 코드베이스를 구축할 수 있습니다.** 

공모전에서의 성공적인 테스트 적용을 응원합니다! 🚀

---

## ✅ **실제 테스트 경험 기록**

### **성공적인 테스트 구현 사례**
```bash
# 2024년 실제 테스트 결과
 Test Files  2 passed (2)
      Tests  38 passed (38)
   Duration  1.26s

# 커버된 파일들
✅ src/utils/env.js (13개 테스트)
✅ utils/validation.js (25개 테스트)
```

### **실무에서 발생한 문제와 해결책**
1. **환경변수 불일치**: 테스트 예상값 vs 실제 .env 값 → 실제 값에 맞춰 수정
2. **이메일 검증 로직**: 너무 엄격한 테스트 케이스 → 실제 라이브러리 동작에 맞춰 조정
3. **필수 필드 검증**: 숫자 0의 falsy 특성 → 문자열 테스트로 변경
4. **URL 검증**: FTP 프로토콜도 유효 → 테스트 케이스에서 제외

### **Claude와의 협업 패턴**
```
사용자: "validation.js 테스트 코드 작성해줘" + 코드 제공
Claude: 테스트_설정_가이드.md 기반으로 38개 테스트 생성
실행: 7개 실패 발견
Claude: 실제 코드 동작 분석 후 테스트 수정
결과: 38개 모두 통과 → 완벽한 테스트 환경 구축
```

### **다음 세션에서 Claude 사용법**
1. **컨텍스트 제공**: `테스트_설정_가이드.md` + `.claude/CLAUDE.md` + 작성한 코드
2. **요청 방식**: "이 코드에 대한 테스트 코드 작성해줘"
3. **자동 생성**: 우아한형제들/토스 패턴 적용된 완전한 테스트
4. **품질 보장**: 실제 코드 기반의 정확한 테스트 생성

---

*"테스트는 품질보증이 아닌 설계 도구다" - Kent Beck*  
*"빠르게 실패하고, 빠르게 배우고, 빠르게 개선하라" - 토스 개발 문화*  
*"실제 사용자 시나리오를 테스트하라" - 우아한형제들 개발 철학*